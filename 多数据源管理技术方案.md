# SpringAI-MCP 动态多数据源管理技术方案

---

## 一、需求分析

### 1.1 核心需求
- ✅ **运行时动态配置**：项目启动后通过Web界面添加/修改数据库连接
- ✅ **多数据源支持**：不同用户/会话可以同时操作多个数据库
- ✅ **用户隔离**：多用户并发访问时互不干扰
- ✅ **连接管理**：支持测试连接、增删改查数据源

### 1.2 当前系统限制
- ❌ 数据库配置写死在 `application.yml` 中
- ❌ 只支持单一数据源
- ❌ 修改配置需要重启应用

---

## 二、核心架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    前端层 (Vue.js + Element Plus)             │
│  ┌──────────────────┐  ┌──────────────────────────────────┐ │
│  │  数据源管理面板   │  │  主查询界面（带数据源选择器）      │ │
│  │ - 添加/编辑/删除  │  │ - 数据源下拉选择                  │ │
│  │ - 测试连接        │  │ - 动态加载数据库结构              │ │
│  │ - 连接状态监控    │  │ - Text2SQL查询                   │ │
│  └──────────────────┘  └──────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↓ HTTP (Header: X-DataSource-Id)
┌─────────────────────────────────────────────────────────────┐
│                    Web过滤器层                                │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  DataSourceContextFilter (拦截器)                     │   │
│  │  - 从请求头提取 X-DataSource-Id                       │   │
│  │  - 设置到 ThreadLocal (兼容虚拟线程)                   │   │
│  │  - 请求结束后清理上下文                               │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    Controller层                               │
│  ┌────────────────────┐  ┌────────────────────────────────┐ │
│  │ DataSourceController│  │ McpController (改造)           │ │
│  │ - 数据源CRUD        │  │ - 使用动态数据源               │ │
│  │ - 测试连接          │  │ - Text2SQL查询                 │ │
│  │ - 获取列表          │  │ - SQL执行                      │ │
│  └────────────────────┘  └────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  核心管理层                                   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  DataSourceContextHolder (ThreadLocal)               │   │
│  │  - 存储当前请求的数据源ID                             │   │
│  │  - 兼容虚拟线程 (ScopedValue)                         │   │
│  └──────────────────────────────────────────────────────┘   │
│                            ↓                                 │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  DynamicDataSourceManager (单例Bean)                 │   │
│  │  - Map<String, HikariDataSource> 数据源池            │   │
│  │  - 创建数据源 (根据配置动态构建 HikariCP)             │   │
│  │  - 获取数据源 (根据上下文ID)                          │   │
│  │  - 销毁数据源 (关闭连接池)                            │   │
│  │  - 测试连接 (验证配置有效性)                          │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  Service层（改造）                            │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  SchemaDiscoveryService                              │   │
│  │  - 从 DynamicDataSourceManager 获取当前数据源         │   │
│  │  - 按数据源ID缓存Schema                               │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  SqlExecutionService                                 │   │
│  │  - 使用当前上下文数据源执行SQL                        │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Text2SqlService                                     │   │
│  │  - 针对当前数据源生成SQL                              │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  数据持久化层                                 │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  DataSourceRepository (持久化存储)                    │   │
│  │  - JSON文件存储 (datasources.json)                   │   │
│  │  - 密码AES加密                                        │   │
│  │  - 启动时自动加载                                     │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、技术选型与实现细节

### 3.1 数据源隔离方案

**方案对比：**

| 方案 | 优点 | 缺点 | 是否采用 |
|------|------|------|---------|
| ThreadLocal | 简单易用，线程安全 | 虚拟线程下可能失效 | ❌ |
| ScopedValue (Java 21+) | 虚拟线程友好，不可变 | 需要Java 21+ | ✅ 优先 |
| 请求作用域Bean | Spring原生支持 | 配置复杂 | ❌ |
| Session存储 | 持久化 | 需要会话管理 | ❌ |

**最终方案：** 使用 **ScopedValue** (Java 24已支持) + **ThreadLocal降级**

```java
// 兼容性实现
public class DataSourceContextHolder {
    // Java 24虚拟线程优先使用 ScopedValue
    private static final ScopedValue<String> SCOPED_DATA_SOURCE_ID =
        ScopedValue.newInstance();

    // 传统线程降级使用 ThreadLocal
    private static final ThreadLocal<String> THREAD_LOCAL_DATA_SOURCE_ID =
        new ThreadLocal<>();

    public static void setDataSourceId(String id) {
        // 根据线程类型选择存储方式
        if (Thread.currentThread().isVirtual()) {
            ScopedValue.runWhere(SCOPED_DATA_SOURCE_ID, id, () -> {});
        } else {
            THREAD_LOCAL_DATA_SOURCE_ID.set(id);
        }
    }
}
```

### 3.2 数据源管理核心逻辑

**DynamicDataSourceManager 职责：**

```java
@Service
public class DynamicDataSourceManager {
    // 数据源缓存池
    private final ConcurrentHashMap<String, HikariDataSource> dataSourcePool =
        new ConcurrentHashMap<>();

    // 默认数据源（来自application.yml）
    private final HikariDataSource defaultDataSource;

    /**
     * 创建新数据源
     */
    public String createDataSource(DataSourceConfig config) {
        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl(config.buildJdbcUrl());
        hikariConfig.setUsername(config.getUsername());
        hikariConfig.setPassword(decryptPassword(config.getPassword()));
        hikariConfig.setDriverClassName(config.getDriverClassName());
        hikariConfig.setMinimumIdle(config.getMinimumIdle());
        hikariConfig.setMaximumPoolSize(config.getMaximumPoolSize());
        hikariConfig.setConnectionTimeout(config.getConnectionTimeout());
        hikariConfig.setPoolName("DynamicPool-" + config.getName());

        HikariDataSource dataSource = new HikariDataSource(hikariConfig);
        dataSourcePool.put(config.getId(), dataSource);
        return config.getId();
    }

    /**
     * 获取当前数据源（根据上下文）
     */
    public DataSource getCurrentDataSource() {
        String dataSourceId = DataSourceContextHolder.getDataSourceId();
        if (dataSourceId == null) {
            return defaultDataSource; // 使用默认数据源
        }
        return dataSourcePool.getOrDefault(dataSourceId, defaultDataSource);
    }

    /**
     * 销毁数据源
     */
    public void destroyDataSource(String id) {
        HikariDataSource dataSource = dataSourcePool.remove(id);
        if (dataSource != null) {
            dataSource.close();
        }
    }

    /**
     * 测试连接
     */
    public boolean testConnection(DataSourceConfig config) {
        try (Connection conn = createTempConnection(config)) {
            return conn.isValid(5); // 5秒超时
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 3.3 数据持久化方案

**存储格式：** JSON文件 (`data/datasources.json`)

```json
{
  "dataSources": [
    {
      "id": "ds-001",
      "name": "生产环境MySQL",
      "type": "mysql",
      "host": "192.168.1.100",
      "port": 3306,
      "database": "production",
      "username": "admin",
      "password": "AES_ENCRYPTED_PASSWORD_HERE",
      "minimumIdle": 5,
      "maximumPoolSize": 20,
      "sslEnabled": true,
      "createdAt": "2025-10-16T10:30:00",
      "createdBy": "user001",
      "isDefault": false,
      "active": true
    }
  ]
}
```

**密码加密：** AES-256-CBC

```java
public class PasswordEncryptor {
    private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String SECRET_KEY = System.getenv("DATASOURCE_SECRET_KEY");

    public static String encrypt(String password) { /* AES加密 */ }
    public static String decrypt(String encrypted) { /* AES解密 */ }
}
```

---

## 四、API设计

### 4.1 数据源管理API

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 获取所有数据源 | GET | `/api/datasources` | 返回数据源列表（不含密码） |
| 获取单个数据源 | GET | `/api/datasources/{id}` | 获取详细信息 |
| 创建数据源 | POST | `/api/datasources` | 创建新数据源 |
| 更新数据源 | PUT | `/api/datasources/{id}` | 更新配置 |
| 删除数据源 | DELETE | `/api/datasources/{id}` | 删除并关闭连接池 |
| 测试连接 | POST | `/api/datasources/test` | 验证配置有效性 |
| 激活数据源 | POST | `/api/datasources/{id}/activate` | 激活/停用 |

### 4.2 请求/响应示例

**创建数据源请求：**
```json
POST /api/datasources
{
  "name": "测试MySQL",
  "type": "mysql",
  "host": "localhost",
  "port": 3306,
  "database": "test_db",
  "username": "root",
  "password": "password123",
  "maximumPoolSize": 10,
  "sslEnabled": false,
  "description": "开发测试数据库"
}
```

**响应：**
```json
{
  "success": true,
  "message": "数据源创建成功",
  "data": {
    "id": "ds-20251016-001",
    "name": "测试MySQL",
    "status": "ACTIVE"
  }
}
```

### 4.3 修改现有API

**Text2SQL查询** (添加数据源头)：
```http
POST /api/mcp/text2sql
Headers:
  X-DataSource-Id: ds-20251016-001
  Content-Type: application/json

Body:
{
  "query": "查询所有用户"
}
```

---

## 五、前端UI设计

### 5.1 数据源管理面板

**功能模块：**

```
┌─────────────────────────────────────────────────────┐
│  数据源管理                                   [+新建] │
├─────────────────────────────────────────────────────┤
│  🔍 搜索: [________________]   类型: [全部▼]        │
├─────────────────────────────────────────────────────┤
│  📊 数据源列表                                       │
│  ┌───────────────────────────────────────────────┐ │
│  │ ● 生产MySQL (ds-001)               [编辑][删除]│ │
│  │   mysql://192.168.1.100:3306/production      │ │
│  │   连接数: 5/20  ✅ 连接正常                    │ │
│  ├───────────────────────────────────────────────┤ │
│  │ ● 测试PostgreSQL (ds-002)          [编辑][删除]│ │
│  │   postgresql://localhost:5432/test           │ │
│  │   连接数: 2/10  ✅ 连接正常                    │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

**新建/编辑对话框：**

```
┌─────────────────────────────────────────────────────┐
│  新建数据源                                    [×]   │
├─────────────────────────────────────────────────────┤
│  基本信息                                           │
│  ┌─────────────────────────────────────────────┐   │
│  │ 数据源名称: [_____________________________] │   │
│  │ 数据库类型: [MySQL ▼]                       │   │
│  │ 描述说明:   [_____________________________] │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  连接配置                                           │
│  ┌─────────────────────────────────────────────┐   │
│  │ 主机地址: [____________] 端口: [3306]       │   │
│  │ 数据库名: [____________]                    │   │
│  │ 用户名:   [____________]                    │   │
│  │ 密码:     [____________] 🔒                 │   │
│  │ ☑ 启用SSL连接                               │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  连接池配置 (高级)                                   │
│  ┌─────────────────────────────────────────────┐   │
│  │ 最小空闲: [5]  最大连接: [20]               │   │
│  │ 超时时间: [30000] ms                        │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  [测试连接]                    [取消]  [保存并激活] │
└─────────────────────────────────────────────────────┘
```

### 5.2 主界面集成数据源选择器

**在现有主界面头部添加：**

```
┌─────────────────────────────────────────────────────┐
│  Text2SQL智能查询                         [用户▼]   │
├─────────────────────────────────────────────────────┤
│  数据源: [生产MySQL (ds-001) ▼]  [管理数据源]        │
│  状态: ✅ 已连接  |  数据库: production              │
└─────────────────────────────────────────────────────┘
```

**数据源切换时：**
1. 清空当前数据库结构缓存
2. 重新加载新数据源的Schema
3. 更新左侧表结构面板
4. 清空查询历史

---

## 六、安全性考虑

### 6.1 密码安全
- ✅ 传输加密：HTTPS
- ✅ 存储加密：AES-256密码加密
- ✅ 密钥管理：环境变量存储加密密钥
- ✅ 前端安全：密码字段不回显

### 6.2 权限控制（可选扩展）
- 用户身份认证（Spring Security）
- 数据源访问权限（RBAC）
- 操作审计日志

### 6.3 SQL注入防护
- 现有的SQL验证管道继续生效
- 禁止动态拼接数据源配置

---

## 七、改造范围评估

### 7.1 新增文件

**后端 (Java):**
```
com.kami.springai.datasource/
├── model/
│   ├── DataSourceConfig.java          (数据源配置实体)
│   ├── DataSourceDTO.java             (DTO，不含密码)
│   └── DataSourceStatus.java          (状态枚举)
├── service/
│   ├── DynamicDataSourceManager.java  (核心管理器)
│   ├── DataSourceContextHolder.java   (上下文持有)
│   ├── DataSourceRepository.java      (持久化)
│   └── PasswordEncryptor.java         (加密工具)
├── controller/
│   └── DataSourceController.java      (REST API)
└── filter/
    └── DataSourceContextFilter.java   (请求拦截器)
```

**前端 (Vue.js):**
```
static/
├── datasource-manager.html            (数据源管理页面)
└── js/
    └── datasource.js                  (数据源管理逻辑)
```

**配置文件:**
```
data/
└── datasources.json                   (数据源配置存储)
```

### 7.2 需要修改的现有文件

| 文件 | 改动内容 | 影响范围 |
|------|---------|---------|
| `SchemaDiscoveryService.java` | 从DynamicDataSourceManager获取数据源 | ⚠️ 中等 |
| `SqlExecutionService.java` | 使用动态数据源执行SQL | ⚠️ 中等 |
| `Text2SqlService.java` | 无需改动（间接使用） | ✅ 无 |
| `SchemaCache.java` | 按数据源ID分组缓存 | ⚠️ 小 |
| `index.html` | 添加数据源选择器 | ⚠️ 小 |
| `app.js` | 添加数据源切换逻辑 | ⚠️ 中等 |
| `application.yml` | 添加默认数据源标识 | ✅ 小 |

### 7.3 依赖变更

**build.gradle 新增依赖：**
```gradle
// 密码加密
implementation 'org.bouncycastle:bcprov-jdk18on:1.78'
```

---

## 八、实现难点与解决方案

### 8.1 虚拟线程兼容性

**问题：** ThreadLocal在虚拟线程下可能失效
**解决：**
```java
// 使用 ScopedValue（Java 21+）
private static final ScopedValue<String> SCOPED_DS = ScopedValue.newInstance();

// 或使用 InheritableThreadLocal（虚拟线程也能继承）
private static final InheritableThreadLocal<String> INHERITABLE_DS =
    new InheritableThreadLocal<>();
```

### 8.2 连接池泄漏风险

**问题：** 用户删除数据源时，可能有正在执行的查询
**解决：**
```java
public void destroyDataSource(String id) {
    HikariDataSource ds = dataSourcePool.remove(id);
    if (ds != null) {
        // 设置为只读，拒绝新连接
        ds.setReadOnly(true);

        // 等待活动连接完成（最多30秒）
        ds.setConnectionTimeout(30000);

        // 优雅关闭
        ds.close();
    }
}
```

### 8.3 缓存失效问题

**问题：** 切换数据源后，缓存的Schema可能不匹配
**解决：**
```java
// 改造SchemaCache，按数据源ID分组
@Cacheable(value = "databaseSchema", key = "#dataSourceId + ':' + #root.methodName")
public DatabaseSchema discoverSchema(String dataSourceId) {
    // ...
}
```

### 8.4 并发安全

**问题：** 多用户同时创建/删除数据源
**解决：**
```java
// 使用 ConcurrentHashMap
private final ConcurrentHashMap<String, HikariDataSource> dataSourcePool;

// 原子操作
dataSourcePool.computeIfAbsent(id, k -> createDataSource(config));
```

---

## 九、实施计划

### 阶段一：核心功能（3天）
- [x] 数据模型设计
- [ ] 动态数据源管理器实现
- [ ] 上下文持有者实现
- [ ] REST API开发
- [ ] 单元测试

### 阶段二：服务层改造（2天）
- [ ] SchemaDiscoveryService改造
- [ ] SqlExecutionService改造
- [ ] 缓存策略调整
- [ ] 集成测试

### 阶段三：前端开发（2天）
- [ ] 数据源管理面板
- [ ] 主界面集成选择器
- [ ] API对接
- [ ] UI/UX优化

### 阶段四：持久化与安全（1天）
- [ ] JSON持久化
- [ ] 密码加密
- [ ] 启动加载机制
- [ ] 安全测试

### 阶段五：测试与优化（1天）
- [ ] 并发压力测试
- [ ] 连接池监控
- [ ] 异常场景测试
- [ ] 性能优化

---

## 十、风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 虚拟线程兼容性问题 | 高 | 中 | 使用ScopedValue + 降级方案 |
| 连接池资源泄漏 | 高 | 低 | 严格生命周期管理 + 监控 |
| 缓存混乱 | 中 | 中 | 数据源ID隔离缓存 |
| 密码泄露 | 高 | 低 | 加密存储 + HTTPS传输 |
| 并发数据不一致 | 中 | 低 | ConcurrentHashMap + 原子操作 |

---

## 十一、后续扩展方向

1. **用户权限管理**：数据源访问权限控制
2. **连接池监控面板**：实时查看连接状态、慢查询
3. **数据源导入/导出**：批量配置管理
4. **多租户支持**：基于租户的数据源隔离
5. **读写分离**：同一数据源的主从配置

---

## 总结

该方案通过以下核心设计实现动态多数据源管理：

✅ **动态创建/销毁** - HikariCP连接池的运行时管理
✅ **线程隔离** - ScopedValue/ThreadLocal确保多用户并发安全
✅ **灵活配置** - Web界面零重启配置
✅ **安全可靠** - 密码加密 + 持久化存储
✅ **兼容现有** - 最小化改造现有代码

---

**文档版本：** v1.0
**创建日期：** 2025-10-16
**最后更新：** 2025-10-16
